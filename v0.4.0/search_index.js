var documenterSearchIndex = {"docs":
[{"location":"basics/#Code-Basics-1","page":"Code Basics","title":"Code Basics","text":"","category":"section"},{"location":"basics/#Notation-1","page":"Code Basics","title":"Notation","text":"","category":"section"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The code solves differential equations of the form","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"partial_t u = mathcalLu + mathcalN(u) ","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"using Fourier transforms on periodic domains. The right side term mathcalLu is a 'linear' part of the equation. The term mathcalN(u) is, in general, a 'nonlinear' part. In FourierFlows, mathcalLu is specified by  physical modules in Fourier space as an array with the same size as hat u, the Fourier transform of u. The nonlinear term mathcalNu is specified by a function.","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"Boundary conditions in all spatial dimensions are periodic. That allows us to expand all variables using a Fourier  decomposition. For example, a variable phi(x t) that depends in one spatial dimension is expanded as:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"phi(x t) = sum_k widehatphi(k t)e^mathrmi k x ","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"where wavenumbers k take the values tfrac2piL_x0pm 1pm 2dots. The equation is time-stepped  forward in Fourier space. That way u becomes the array with all Fourier coefficients of the solution.","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The coefficients for the linear operator mathcalL are stored in an array called LC. The term mathcalN(u)  is computed for by calling the function calcN!.","category":"page"},{"location":"basics/#Basic-steps-for-solving-a-problem:-step-through-an-example-script-1","page":"Code Basics","title":"Basic steps for solving a problem: step through an example script","text":"","category":"section"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"To illustrate the basic steps for solving a problem consider the 1D Kuramoto-Sivashinsky equation for u(x t):","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"partial_t u + partial_x^4 u + partial_x^2 u + upartial_x u = 0 ","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"which in Fourier space reads:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"partial_t widehatu = underbrace(- k^4 + k^2) widehatu_mathcalLwidehatu\n+ underbracewidehat -upartial_x u _mathcalN(widehatu) ","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"A FourierFlows.Problem is composed of the following types:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"Grid (OneDGrid in this case)\nParams (empty in this case)\nVars, which holds u, partial_x u, upartial_x u and their Fourier transforms widehatu, widehatpartial_x u, widehatupartial_xu.\nEquation, which holds the linear coefficients LC and a function calcN! that computes mathcalN(widehatu).\nTimeStepper for stepping the solution forward,\nState, which holds the solution sol and current time t.","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The example script found in  examples/kuramotosivashinsky/trefethenexample.jl demonstrates the above steps  needed to construct a KuramotoSivashinsky Problem. For this we call  prob = Problem(nx=nx, Lx=Lx, dt=dt, stepper=\"ETDRK4\"). Looking into the  Problem  function we can see the above steps:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"function Problem(; nx=256, Lx=2π, dt=0.01, stepper=\"RK4\")\n    g  = OneDGrid(nx, Lx)\n    pr = Params()\n    vs = Vars(g)\n    eq = Equation(pr, g)\n    ts = TimeStepper(stepper, dt, eq.LC, g)\n    FourierFlows.Problem(g, vs, pr, eq, ts)\nend","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"OneDGrid(nx, Lx) builds a one-dimensional grid with a Fourier wavenumber array kr:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"i1 = 0:Int(nx/2)\ni2 = Int(-nx/2+1):-1\nkr = Array{T}(2π/Lx*cat(1, i1))","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"For real-valued fields we use rfft and thus only positive wavenumbers are involved: array kr.  Foe example, with nx=8 and Lx=2π the wavenumber grids are: k = [0, 1, 2, 3, 4, -3, -2, -1] and  kr = [0, 1, 2, 3, 4].","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The construction of the grids only works for an even number of grid points. Moreover, the Fourier transforms are  most efficient when the number of grid points is the product of powers of 2 and 3. For example:  2^7=128, 2^6 3^1=192, or 2^8=256.","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"Vars(g) initializes variables u, ux, and uux as real valued arrays of length nx and variables  uh, uxh, and uuxh as complex valued arrays of length nkr = Int(nx/2+1) (the same length as kr).  We use the convention that the Fourier transform of a variable is appended with an h, which stands for 'hat'. For example, the transform of phi is phih.","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The array LC is constructed by the Equation constructor","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"function Equation(p, g)\n  LC = @. g.kr^2 - g.kr^4\n  FourierFlows.Equation(LC, calcN!)\nend","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"One of the fields of Equation is the function calcN!,  which computes the nonlinear term mathcalN(widehatu), storing the result in N:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"function calcN!(N, sol, t, s, v, p, g)\n  @. v.uh = sol\n  @. v.uxh = im*g.kr*sol\n  ldiv!(v.u, g.irfftplan, v.uh) # irfft\n  ldiv!(v.ux, g.irfftplan, v.uxh)\n  @. v.uux = v.u*v.ux\n  mul!(v.uuxh, g.rfftplan, v.uux)\n  @. N = -v.uuxh\n  dealias!(N, g)\n  nothing\nend","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The time-stepper is constructed and stored as ts. Finally, all supertypes are gathered together as a  FourierFlows.Problem.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"newcommandsqrmboxsqr\nnewcommandsawmboxsaw\nnewcommandindmboxind\nnewcommandsgnmboxsgn\nnewcommanderfcmboxerfc\nnewcommanderfmboxerf\n\n An average\nnewcommandavg1mathrmavg 1 \n The right way to define new functions\nnewcommandsechmathoprm sechnolimits\nnewcommandcosechmathoprm cosechnolimits\n\n A nice definition\nnewcommanddefnstackrelmathrmdef=\n \n\nnewcommandol1overline1\n\n\n Various boldsymbols\nnewcommandbxboldsymbolx\nnewcommandbyboldsymboly\nnewcommandbqboldsymbolq\nnewcommandbpsiboldsymbolpsi\nnewcommandbuboldsymbolu\nnewcommandbGboldsymbolmathcalG\nnewcommandGmathcalG\nnewcommandbaboldsymbola\nnewcommandbbboldsymbolb\nnewcommandbcboldsymbolc\nnewcommandbvboldsymbolv\nnewcommandbkboldsymbolk\nnewcommandbXboldsymbolX\nnewcommandbrboldsymbolr\nnewcommandJmathsfJ\nnewcommandDmathsfD\nrenewcommandLmathsfL\nnewcommandsLmathsfL\nnewcommandGboldsymbolmathsfG\nnewcommandbAboldsymbol A\nnewcommandbUboldsymbol U\nnewcommandbEboldsymbol E\nnewcommandbJboldsymbol J\nnewcommandbXXboldsymbol mathcalX\nnewcommandbFFensuremath boldsymbol F\nnewcommandbFensuremath boldsymbol F^sharp\nnewcommandbLensuremath boldsymbol L\nnewcommandbIensuremath boldsymbol I\nnewcommandbNensuremath boldsymbol N\n\nnewcommandIensuremath mathsfI\nrenewcommandLensuremath mathsfL\nrenewcommandSensuremath mathsfS\n\nnewcommandbSigmaensuremath boldsymbol Sigma\nnewcommandkmaxk_mathrmmax\nnewcommandbnablaboldsymbolnabla\nnewcommandbcdotboldsymbolcdot\n\ndefiirm i\ndefddrm d\ndefeerm e\ndefDDrm D\n Cals here \n\n  Euler caligraphics \nnewcommandAmathscrA\n newcommandBmathscrB\nnewcommandBmathcalB\nnewcommandEmathscrE\nnewcommandFmathscrF\nnewcommandKmathscrK\nnewcommandNmathscrN\nnewcommandUmathscrU\nnewcommandLLmathscrL\nnewcommandMmathscrM\nnewcommandTmathscrT\ndeflalangle\ndefrarangle\ndeflaaleft langle\ndefraaright rangle\ndefEkmathrmEk\nnewcommandhzonh_mathrmzon\nnewcommandlaptriangle\nnewcommandppartial\nnewcommandhalf tfrac12\nnewcommandgradboldsymbol nabla\nnewcommandpdetextscpde\nnewcommandodetextscode\nnewcommandcctextsccc\nnewcommanddctextscdc\nnewcommanddbctextscdbc\nnewcommandbyutextscbyu\nnewcommandrhstextscrhs\nnewcommandlhstextsclhs\nnewcommandcom\nnewcommandper\nnewcommandzzeta\nnewcommandheta\nrenewcommand(left(\nrenewcommandleft\nrenewcommand)right)\nrenewcommandright\nnewcommandleftlangle\nrenewcommandrightrangle\nrenewcommandAmathcalA\nrenewcommandNmathcalN\nnewcommandCmathcalC\nnewcommandtransptextrmT\nnewcommandzhatwidehatmathbfz\n\nnewcommandbitvphantomdotW\nnewcommandsdb","category":"page"},{"location":"forcing/#Forcing-1","page":"Forcing","title":"Forcing","text":"","category":"section"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"The code implements forcing in various modules (currently in TwoDTurb and BarotropicQG). Forcing can be either deterministic or stochastic (random). For deterministic forcing the implementation is straightforward; for stochastic forcing there are two main train of thoughts: Itô calculus and Stratonovich calculus.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Both stochastic calculi give the same results. But once we decide to use one of the two calculi we have to remain consistent and use that calculus for everywhere. There is a lot of confusion and mostly the confusion stems from not using the same stochastic calculus consistently throughout the computation but rather interchanging between the two.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"FourierFlows uses Stratonovich calculus throughout the code. This choise was made because Stratonovich calculus works the same with both stochastic and deterministic forcing, i.e. with Stratonovich calculus we have the same chain rules for differentiation for stochastic functions as the chain rules we learn in normal-deterministic calculus). Therefore, the code written as is does not really \"care\" of what forcing the user implements.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"If you are interested in learning more regarding the two stochastic calculi and how they are numerically implemented then read on; otherwise you can skip this section of the documentation and go to the Module Tutorials.","category":"page"},{"location":"forcing/#Stochastic-Differential-Equations-(SDEs)-1","page":"Forcing","title":"Stochastic Differential Equations (SDEs)","text":"","category":"section"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"A differential equation in the form:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\n\tfracdd xdd t = f(x)comquad x(t_0)=0com\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"can also be written in an integral form:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\n\tx(t) = int_t_0^t f(x(s))dd sper\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"In a similar manner, a stochastic differential equation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\n\tdd x = f(x)dd t + g(x)dd W_tcomquad x(t_0)=0com\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"with dd W_t a white-noise process, can be written in an integral form as:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\n\tx(t) = int_t_0^t f(x(s))dd s + int_t_0^t g(x(s))dd W_s per\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Of course now, the last integral is a stochastic integral and there is not a single straight-forward way of computing it –- there are a lot of different ways we can approximate it as a Riemannian sum and each of them leads to a different answer. The two most popular ways for computing such stochastic integrals are:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"colorGreentextItô int_t_0^t g(x(s))dd W_sapproxsum_j gleft(x(t_j)right)(W_j+1-W_j)com\ncolorMagentatextStratonovich int_t_0^t g(x(s))dd W_s approx sum_j gleft(xleft(half(t_j+t_j+1)right)right)(W_j+1-W_j)per","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Because the white noise process is not continuous the two definitions do not converge to the same result; the two definitions give thoroughly different results. And to overcome that they come along with different chain rules, i.e., chain rules that are not necessarily the same as those in plain old calculus.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"An SDE can be written also in differential form. Because we cannot formally form dd Wdd t, since W is nowhere differentiable, we write an SDE in differential form as:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"colorGreentextItô dd x_t = f(x_t)dd t + g(x_t)dd W_tcom\ncolorMagentatextStratonovich dd x_t = f(x_t)dd t + g(x_t)circdd W_tper","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"The circle in g(x_t)circdd W_t is used to differentiate between Itô or Stratonovich calculus.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"A variable change y=G(x) is done as follows according to the two different calculi:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"colorGreentextItô dd y_t = fracdd Gdd xdd x_t + half g(x_t)^2 fracdd^2 Gdd x^2dd t =left fracdd Gdd xf(x_t) + half g(x_t)^2 fracdd^2 Gdd x^2rightdd t + fracdd Gdd xg(x_t)dd W_tcom\ncolorMagentatextStratonovich dd y_t  = fracdd Gdd xdd x_t =fracdd Gdd x f(x_t) dd t + fracdd Gdd xg(x_t)circdd W_tper","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"The above are the so called stochastic chain rules. All derivatives of G are evaluated at x_t.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"It's easy to see that the extra drift-term in Itô's interpretation of the stochastic integral, i.e., colorGreenhalf g^2 dd^2Gdd x^2  is exactly equal to the ensemble mean of the Stratonovich stochastic integral. That's because the Itô stochastic integral has, by construction, zero ensemble mean since at every instant the noise is multiplied with g evaluated before the action of the noise; g and dd W are uncorrelated and thus:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\ncolorGreenlaa g(x_t)dd W_t raa =0quadtextwhilequad colorMagentalaa g(x_t)circdd W_t raa ne 0per\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"The above is demonstrated by evaluating the simple stochastic integral:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"colorGreentextItô laa int_t_0^t W_sdd W_s raa approxsum_j laa W_j(W_j+1-W_j)raa\ncolorGreenhspace73em = sum_j laa W_j W_j+1raa - laa W_jW_jraa sim sum_j t_j - t_j = 0 com\ncolorMagentatextStratonovich laaint_t_0^t W_scircdd W_sraa approx sum_j laa frac12(W_j + W_j+1) (W_j+1-W_j)raa \ncolorMagentahspace73em = frac12sum_j laa W_j+1 W_j+1raa - laa W_j W_jraa  sim frac12sum_j t_j+1 - t_j = fract2per","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"SDEs rarely can be solved in closed form; most often numerical solution of SDEs is brought to the rescue. Itô calculus has the advantage that is very easily implemented numerically. On the other hand, the chain rule in Stratonovich calculus coincides with that in normal calculus. This stems from the fact that in the Stratonovich interpretation the white noise process is as a series of colored noise processes with the de-correlation time tending to zero. This made Stratonovich calculus more popular in the physics community. A nice discussion on the differences and similarities between the two calculi is given by van Kampen.","category":"page"},{"location":"forcing/#A-simple-Stochastic-Differential-Equation-(SDE):-the-Ornstein–Uhlenbeck-process-1","page":"Forcing","title":"A simple Stochastic Differential Equation (SDE): the Ornstein–Uhlenbeck process","text":"","category":"section"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"One of the simpler SDEs is the Ornstein–Uhlenbeck process. A variation of which is:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\n\tx(t) = int_t_0^t -mu x(s)dd s + int_t_0^t sqrtsigmadd W_s perlabeleqOU\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Note that in differential form this is:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\n\tdd x_t = -mu x_t dd t + sqrtsigmadd W_s perlabeleq1\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Luckily, here there is no need to distinguish between Itô and Stratonovich. This is because g is independent of x(t). But we stress that  this is often not the case; it is only a fortuitous coincident here.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"How do we time-step this SDE numerically? Let us assume a discretization of time into time-steps of tau: t_j=(j-1)tau. (What follows can be easily transfer to non-uniform time discretization.) With that, we denote x_jdefn x(t_j). Then the Euler–Mayorama time-step scheme for \\eqref{eq:1} is","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\n\tx_j+1 = x_j + (-mu x_j)tau + sqrtsigma(W_j+1-W_j)per\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Now let us ask the following question: How can we compute the work done by the noise? In other words, if we are interested in the evolution of the \"energy\" Edefn half x^2, how is the noise term attributing in the growth of E? To answer that we first have to find the SDE that energy E obeys. But, in doing so, it is important to adopt a single interpretation for computing stochastic integrals as now a transformation of variables is needed. That is, depending on whether we choose to interpret the stochastic integrals according to Itô or to Stratonovich calculus, E evolves as:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\ncolorGreentextItô  dd E_t  = left( -2mu E_t + half sigma right)dd t  + x_t sqrtsigmadd W_tcomlabeleqE_ito\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\ncolorMagentatextStratonovich dd E_t  = -2mu E_t  dd t + x_tcirc sqrtsigmadd W_tperlabeleqE_str\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"How do we compute the work P done by the noise? It is:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"colorGreentextItô P_t = half sigma dd t + sqrtsigma x_t dd W_t approx  half sigma + sqrtsigma x_j (W_j+1-W_j)com\ncolorMagentatextStratonovich P_t =  x_t circsqrtsigma dd W_t approx sqrtsigma xleft(half(t_j+t_j+1)right)(W_j+1-W_j)per","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Say we didn't know the rules for transforming Stratonovich to Itô and we were wondering what is the extra drift term we have to include in the Itô formulations, i.e. the halfsigma term. We can compute the Itô's drift-term using that it is exactly equal to la x_tcircsqrtsigmadd W_tra; and for the latter we can use the \"usual\" calculus. That is, rewrite \\eqref{eq:OU} as:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\ndotx = -mu x + xicomlabeleqOUcont\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"where xi(t) is understood to be the \"continuous\" version of the white-noise process which is formally only understood in terms of distributions. The forcing xi has the properties:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"laa xi(t)raa = 0 quadtextandquad laa xi(t)xi(t)raa = sigma delta(t-t)per","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Thus we need to compute la P_t ra = la x(t) xi(t) ra. But \\eqref{eq:OUcont} has formally the solution:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"x(t) = ee^-mu t x(0) + int_0^t ee^-mu(t-s)xi(s)dd sper","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"and utilizing the above we get","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"la P_t ra = la x(t) xi(t)  ra\n=  ee^-mu t underbracela x(0)xi(t)ra_=0 + int_0^t ee^-mu(t-s)la xi(t)xi(s)radd s\n= sigma int_0^t ee^-mu(t-s) delta(t-s)dd s =  fracsigma2 per","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Above we used that int_0^tdelta(t-s)dd s = half, which is consistent with Stratonovich symmetric interpretation of stochastic integrals.","category":"page"},{"location":"forcing/#Numerical-implementation-1","page":"Forcing","title":"Numerical implementation","text":"","category":"section"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"How do we time-step \\eqref{eq:E_ito}? We use the Euler–Maruyama time-stepping scheme:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"\tE_j+1 = E_j + left(-2mu E_j + fracsigma2right)tau + sqrtsigmax_j(W_j+1-W_j)per","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"However, we cannot use Euler–Maruyama for time-stepping \\eqref{eq:Estr} since the Euler–Maruyama is \"Itô\"-thinking. To time-step \\eqref{eq:Estr} we have to approximate g in the middle of the time-step. There are many ways to do that, one of which is the, so called, Euler–Heun method:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"\twidetildeE_j+1 = E_j + (-2mu E_j)tau + sqrtsigmax_j(W_j+1-W_j)com\n\tE_j+1 = E_j + left(-2mu fracE_j+widetildeE_j+12right)tau + sqrtsigmafracx_j+x_j+12(W_j+1-W_j)per","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"(Image: energy_comparison)","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Figure above shows a comparison of the energy evolution as done from:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"direct computation as half x_t^2,\ntime-integration of \\eqref{eq:E_ito}, and\ntime-integration of \\eqref{eq:E_str}.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Figures below show the ensemble mean energy budgets (using 1000 ensemble members) as computed using Itô and Stratonovich. For the energy budget to close we have to be consistent: if we time-step the energy equation based on Stratonovich calculus then we must compute the work also according to Stratonovich. (For more details see examples/forcing/simpleSDEItoStratonovich.jl.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"(Image: energy_budgets_Ito) (Image: energy_budgets_Stratonovich)","category":"page"},{"location":"forcing/#A-simple-Stochastic-Partial-Differential-Equation-(SPDE)-1","page":"Forcing","title":"A simple Stochastic Partial Differential Equation (SPDE)","text":"","category":"section"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"We want now to transfer all the knowledge we got from the previous sections to PDEs. In particular we'll focus on the simple SPDE:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"\\begin{equation} \\partial_t \\nabla^2\\psi(\\bx, t) =  -\\mu \\nabla^2\\psi(\\bx, t) + \\xi(\\bx,t)\\com\\label{eq:PDEcont} \\end{equation}","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"which is also equivalently written as:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"dd nabla^2psi_t(bx) = -mu nabla^2 psi_t (bx) dd t + sqrtsigma dd W_t (bx) per","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"The form \\eqref{eq:PDEcont} is the continuous version understood in the Stratonovich interpretation (similar to \\eqref{eq:OUcont}). Thus, forcing xi obeys now:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"laxi(bxt)ra = 0 quadtextandquadlaxi(bxt)xi(bxt) ra= Q(bx-bx)delta(t-t)com","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"that is the forcing is white in time but spatially correlated; its spatial correlation is prescribed by the function Q which is, necessarily, homogeneous in all its arguments (see discussion by Constantinou; Appendix A).","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"The above describes the vorticity evolution of a two-dimensional fluid nabla^2psi which is stochastically forced while dissipated by linear drag mu. The energy of the fluid is:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"E = halfoverlinegradpsi^2^xy = -halfoverlinepsinabla^2psi^xycom","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"where the overbar denotes average over x and y. To obtain the energy equation we multiply \\eqref{eq:PDEcont} with -psi and average over the whole domain. Thus, the work done by the forcing is given by the term:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"P = -overlinepsixi^xycom","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"but the above is a stochastic integral and it is meaningless without a rule for computing the stochastic integral.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Numerically, the work done by the forcing can be obtained Stratonovich-wise as:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginalign\nP_j = -overlinefracpsi(bxt_j)+psi(bxt_j+1)2  xi(bxt_j+1) ^xycom\nendalign","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"or Itô-wise","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginalign\nP_j = -overline psi(bxt_j) xi(bxt_j+1) ^xy + textdriftcom\nendalign","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"But how much is the Itô drift term in this case? As in the previous section, the drift is precisely the ensemble mean of the Stratonovich work, i.e.:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"textrmIto drift= -overline launderbracepsi(bxt)circ  xi(bxt)_textrmStratonovich ra ^xycom","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"But again the above can be computed relatively easy if we use the \"formal\" solution of \\eqref{eq:PDEcont}:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"psi(bxt) = ee^-mu tpsi(bx0) + int_0^t ee^-mu(t-s)nabla^-2xi(bxs)dd scom","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"which implies","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"textdrift = -overlineee^-mu tunderbracelaapsi(bx0) xi(bxt)raa_=0 ^xy - int_0^t ee^-mu(t-s)overlinenabla^-2laa xi(bxs)xi(bxt)raa^xydd s \n= -int_0^t ee^-mu(t-s)overlineunderbraceleftnabla^-2 Q(bx)rightbig_bx=0_textindependent of xydelta(t-s)^xydd s = -frac12 nabla^-2 Q(bx)big_bx=0 \n= -frac12 leftnabla^-2 int fracdd^2bk(2pi)^2 widehatQ(bk)ee^iibkbcdotbx right _bx=0\n= int fracdd^2bk(2pi)^2 fracwidehatQ(bk)2k^2per","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Thus, the drift, or in this case the mean energy input rate by the stochastic forcing, is precisely determined from the spatial correlation of the forcing. Let us denote:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"varepsilon defn int fracdd^2bk(2pi)^2 fracwidehatQ(bk)2k^2perlabeleqdef_epsilon","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Therefore, work for a single forcing realization is computed numerically as:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginalign\ncolorGreentextItô colorGreen P_j  =  -overline psi(bxt_j) xi(bxt_j+1) ^xy  + varepsiloncom\ncolorMagentatextStratonovich  colorMagentaP_j = -overlinefracpsi(bxt_j)+psi(bxt_j+1)2  xi(bxt_j+1) ^xyper labeleqPtStrat\nendalign","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Remember, previously the work done by the stochastic forcing was:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"dd P_t = colorGreenfracsigma2dd t + sqrtsigmax_tdd W_t = colorMagentasqrtsigma x_tcircdd W_tcom","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"and by sampling over various forcing realizations:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"langle dd P_trangle = fracsigma2dd t = langlesqrtsigma x_tcircdd W_trangle","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"The code uses Stratonovich. For example, the work done by the forcing in the TwoDTurb module is computed based on \\eqref{eq:PtStrat} with the function","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"@inline function work(s, v::ForcedVars, g)\n  @. v.Uh = g.invKKrsq * (v.prevsol + s.sol)/2.0 * conj(v.Fh)\n  1/(g.Lx*g.Ly)*FourierFlows.parsevalsum(v.Uh, g)\nend","category":"page"},{"location":"forcing/#A-less-simple-SPDE-1","page":"Forcing","title":"A less-simple SPDE","text":"","category":"section"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"It turns out that nothing changes if we include the nonlinear terms in the vorticity equation:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"beginequation\npartial_t nabla^2psi(bx t) + J(psinabla^2psi) =  -mu nabla^2psi(bx t) + xi(bxt)perperlabeleqPDEcont2\nendequation","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"The nonlinearity does not alter the Itô drift; thus the ensemble mean energy input by the stochastic forcing, remains the same. We can easily verify this from the \"formal\" solution of \\eqref{eq:PDEcont2}:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"psi(bxt) = ee^-mu tpsi(bx0) + int_0^t ee^-mu(t-s)nabla^-2xi(bxs)dd s - int_0^t nabla^-2Jleft(psi(bxs)nabla^2psi(bxs)right)dd scom","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"When multiplied with xi(bxt) the last term vanishes since its only non-zero contribution comes from the point s=t which is of measure zero (in the integrated sense).","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"Figure below shows the energy budgets for a numerical solution of \\eqref{eq:PDEcont2}  starting from rest (psi(bx0)=0) in a doubly periodic square domain of size L (examples/twodturb/IsotropicRingForcing.jl). The forcing was prescribed to have power in a narrow ring in wavenumber space:","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"widehatQ(bk)propto ee^-(bk-k_f)^2(2delta_f^2)com","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"with k_f L(2pi) = 12 and delta_f L(2pi) = 2. The mean energy input rate was set to varepsilon = 01.","category":"page"},{"location":"forcing/#","page":"Forcing","title":"Forcing","text":"(Image: energy_budgets_SPDE_Stratonovich)","category":"page"},{"location":"#FourierFlows.jl-Documentation-1","page":"Home","title":"FourierFlows.jl Documentation","text":"","category":"section"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Install FourierFlows.jl from the julia REPL prompt with","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"FourierFlows\")","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"FourierFlows provides a framework to write solvers for partial differential equations on periodic domains with Fourier-based pseudospectral methods. We support 1- and 2-dimensional domains at the moment.","category":"page"},{"location":"#Examples-1","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"For examples of FourierFlows.jl in action, see  GeophysicalFlows.jl","category":"page"},{"location":"#Developers-1","page":"Home","title":"Developers","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"FourierFlows is currently being developed by Gregory L. Wagner and  Navid C. Constantinou.","category":"page"},{"location":"#Cite-1","page":"Home","title":"Cite","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The code is citable via zenodo.","category":"page"},{"location":"man/types/#Private-types-1","page":"Private types","title":"Private types","text":"","category":"section"},{"location":"man/types/#Private-types-in-module-FourierFlows:-1","page":"Private types","title":"Private types in module FourierFlows:","text":"","category":"section"},{"location":"man/types/#","page":"Private types","title":"Private types","text":"Modules = [FourierFlows]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"man/types/#FourierFlows.Problem","page":"Private types","title":"FourierFlows.Problem","text":"Problem(sol, clock, grid, eqn, vars, params, timestepper)\n\nInitialize a FourierFlows problem on grid g, with variables v, parameters p, equation eq, and timestepper ts.\n\n\n\n\n\n","category":"type"},{"location":"man/functions/#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions/#Functions-exported-from-FourierFlows:-1","page":"Functions","title":"Functions exported from FourierFlows:","text":"","category":"section"},{"location":"man/functions/#","page":"Functions","title":"Functions","text":"Modules = [FourierFlows]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"man/functions/#FourierFlows.TimeStepper","page":"Functions","title":"FourierFlows.TimeStepper","text":"TimeStepper(stepper, eq, dt=nothing)\n\nGeneralized timestepper constructor. If stepper is explicit, dt is not used.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#FourierFlows.cxtype-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Functions","title":"FourierFlows.cxtype","text":"cxtype(T)\n\nReturns T when T is Complex, or Complex{T} when T is Real.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.dealias!-Tuple{Any,OneDGrid}","page":"Functions","title":"FourierFlows.dealias!","text":"dealias!(a, g, kalias)\n\nDealias a on the grid g with aliased x-wavenumbers kalias.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.devzeros-Tuple{Any,Any,Any}","page":"Functions","title":"FourierFlows.devzeros","text":"devzeros(dev, T, dims)\n\nReturns an array like A of type T, but full of zeros.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.fltype-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Functions","title":"FourierFlows.fltype","text":"fltype(T)\n\nReturns T when T<:AbstractFloat or Tf when T<:Complex{Tf}.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.gridpoints-Union{Tuple{TwoDGrid{T,A,Tfft,Trfft} where Trfft where Tfft}, Tuple{A}, Tuple{T}} where A where T","page":"Functions","title":"FourierFlows.gridpoints","text":"gridpoints(g)\n\nReturns the collocation points of the grid g in 2D or 3D arrays X, Y (and Z).\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.increment!-Tuple{Any}","page":"Functions","title":"FourierFlows.increment!","text":"increment!(diag)\n\nIncrement the Diagnostic diag, or an array of Diagnostics diags.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.innereltype-Tuple{Any}","page":"Functions","title":"FourierFlows.innereltype","text":"innereltype(x)\n\nRecursively determine the 'innermost' type in by the collection x (which may be, for example, a collection of a collection).\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.savediagnostic-Tuple{Any,Any,Any}","page":"Functions","title":"FourierFlows.savediagnostic","text":"savediagnostic(diag, diagname)\n\nSave diagnostics in diag to file, labeled by diagname.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.saveoutput-Tuple{Any}","page":"Functions","title":"FourierFlows.saveoutput","text":"saveoutput(out)\n\nSave the fields in out.fields to out.path.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.saveproblem-Tuple{Any,Any}","page":"Functions","title":"FourierFlows.saveproblem","text":"saveproblem(prob, filename)\n\nSave certain aspects of a problem.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem,Any,Int64}","page":"Functions","title":"FourierFlows.stepforward!","text":"stepforward!(prob, diags, nsteps)\n\nStep forward prob for nsteps, incrementing diags along the way. diags may be a single Diagnostic or a Vector of Diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem,Int64}","page":"Functions","title":"FourierFlows.stepforward!","text":"stepforward!(prob, nsteps)\n\nStep forward prob for nsteps.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem}","page":"Functions","title":"FourierFlows.stepforward!","text":"stepforward!(prob)\n\nStep forward prob one time step.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.superzeros-Tuple{Any,AbstractArray}","page":"Functions","title":"FourierFlows.superzeros","text":"superzeros(T, A)\n\nReturns an array like A, but full of zeros. If innereltype(A) can be promoted to T, then the innermost elements of the array will have type T.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#FourierFlows.update!-Tuple{Any,Any}","page":"Functions","title":"FourierFlows.update!","text":"update!(diag)\n\nUpdate diag.\n\n\n\n\n\n","category":"method"}]
}
